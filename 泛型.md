#### 1.泛型是什么？泛型的优点？

>泛型是一种参数化类型的机制，将类型也当作一种参数，提高编译时的类型安全。
		
	 * 优点：
		
		   1.提高代码重用性。使用了泛型后，就不需要因为参数类型不同而编写多个类似代码。
		
		   2.保护类型安全，将运行时可能出现的错误转化为编译时期的错误。
		
		   3.避免了显式的强制类型转换。

#### 2.List<String>能否转为List<Object>？

>不可以，虽然String为Object的子类，但List<String>与List<Object>没有父类子类关系，所以不可以转换。但是List<String>可以转化为List< ? extends Object>, 因为List<? extend Object> 可以看作List<String>的父类，但转化后只能用于读取，无法用于修改写入。

#### 3.Java的泛型是如何工作的 ? 什么是类型擦除 ?

>泛型机制正常工作时，会在编译器编译时进行类型检测，若通过则会进行类型擦除并在类型擦除出现的地方插入强制类型转换的指令。在JVM运行时，是看不到有关泛型的任何信息的，看到的只是一个普通的类，接口或者方法。
>
>而所谓的类型擦除指的是，有关泛型的信息会在进入JVM前被擦除，编译器会将Java代码中相应的类型替换掉，其中若无限定则替换为Object类，若有限定上限则替换为第一个限定类型（如 T extends Serializable & String，则替换为Serializable）

#### 4.什么是泛型中的限定通配符和非限定通配符 ?.

>* 限定通配符：
>
>  	即 <？extends T>与<?  super T>，其中前者用于限定类型上界，必须为T类型或者其子类。后者用于限定类型下界，该类必须为T类型或者其父类。
>
>*   非限定通配符：
>
>  	即<?>，没有进行限定，可以用任何类型来替代。

#### 5.List<? extends T>和List <? super T>之间有什么区别 ?

> List<? extends T>可以接受任何T类型或者继承自T的类型的List，而List<? super T>可以接受任何T或者T的父类构成的List。

#### 6.如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?

> 需要使用泛型占位符(一般为大写字母，如T，K，V)来占据原来应该写类型的地方，比如：
>
> Public static <T> T sameOne(T exm){
>
> }

#### 7. Java中如何使用泛型编写带有参数的类?

> 形如：Public class Pair<T>{
>
> 	private T  first;
>
> }

#### 8.数组可以使用泛型么？

> 数组不可以使用泛型，泛型一般适用于集合。除此以外，需要特别注意也不可以创建参数化类型的数组。

#### 9.Java中List<Object>和原始类型List之间的区别?

> 1.在编译时编译器不会对原始类型List进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受哪些类型的对象，比如String或Integer。
>
> 2.可以把任何带参数的泛型类型传递给接受原始类型List的方法，但却不能把List<String>传递给接受List<Object>的方法，因为会产生编译错误。

#### 10.List<String>和原始类型List之间的区别？

> 1.List<String>是类型安全的，会在编译时进行类型检查，而原始类型不会。
>
> 2.List<String>不需要使用显式强制类型转换，但是List却需要进行强制类型转化。
